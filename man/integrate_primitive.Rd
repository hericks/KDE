% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integrate_primitive.R
\name{integrate_primitive}
\alias{integrate_primitive}
\title{Primitive Integration}
\usage{
integrate_primitive(
  integrand,
  lower,
  upper,
  subdivisions = 1000L,
  check = FALSE
)
}
\arguments{
\item{integrand}{a \code{R} function taking a single numeric argument and
returning a numeric vector of the same length. Further the function should
be integrable in the mathematical sense.}

\item{lower}{finite numerical scalar; the lower bound for the integration.}

\item{upper}{finite numerical scalar; the upper bound for the integration.}

\item{subdivisions}{positive numerical scalar; the number of evaluation
points used in the procedure.}

\item{check}{logical; if \code{TRUE} activate the collection of an additional
measure of convergence.}
}
\value{
\code{integrate_primitive} returns a named list containing the entries
\code{value} and \code{rel_error} for the integration value and relative
error respectively. If the \code{check} parameter is not set
\code{rel_error} will always be equal to \code{NULL}.
}
\description{
\code{integrate_primitive} integrates an in the mathematical
sense integrable function over a compact interval using a basic
step-function approximation.
}
\details{
The \code{KDE} package has to frequently handle functions, which are
integrable in the mathematical sense but are hard to integrate consistently
using the base \code{R} function \code{integrate} and equivalent choices.
The typical integration methods often fail for non-smooth functions or functions
with a support consisting of multiple narrow disjoint intervals.

Since the function to integrate is often computationally cheap to evaluate,
approximating the function on a narrow grid and integrating the approximation
as primitive function yields a practical approach.

\code{integrate_primitive} makes use of this approach. The support has to
be finite to allow for a discretisation grid. In particular \code{lower}
and \code{upper} must be finite. The number of evaluation points is
specified in the positive numerical parameter \code{subdivisions}. In
particular a higher number of subdivisions yields a more accurate result at
the expense of longer runtimes. Points at which the integrand takes
non-finite values will be ignored by the primitive
approximation.

The \code{check} parameter can be set to enable the collection of an
additional measure of convergence \code{rel_error}. The relative error is
calculated by computing the integral for increasing numbers of subdivisions
and comparing the successive results.
}
\seealso{
\code{\link{IntegrableFunction}} as application example for \code{integrate_primitive}.
}
